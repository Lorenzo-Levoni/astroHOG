import numpy as np
import matplotlib.pyplot as plt
from astropy.io import fits
from scipy import ndimage
import imageio.v2 as imageo
from tqdm import tqdm

# Funzione vprint per stampe condizionali
def vprint(obj, verbose=True):
    if verbose:
        print(obj)

# Funzione principale che calcola la correlazione spaziale
def HOGcorr_ima_circ_align(ima1, ima2, s_ima1=None, s_ima2=None, pxsz=1., ksz=1., res=1., nruns=0, mask1=None, mask2=None, gradthres1=None, gradthres2=None, weights=None, verbose=True):
    """
    Calcola la correlazione spaziale tra ima1 e ima2 usando il metodo HOG e l'allineamento circolare.

    Parametri
    ----------
    ima1 : array della prima immagine da confrontare 
    ima2 : array della seconda immagine da confrontare
    s_ima1 : deviazione standard per ima1 (per simulazioni Monte Carlo)
    s_ima2 : deviazione standard per ima2 (per simulazioni Monte Carlo)
    pxsz : dimensione del pixel
    ksz : dimensione del kernel derivativo in unità di pixel
    nruns : numero di run Monte Carlo

    Ritorna
    -------
    circstats : statistiche circolari del metodo di allineamento
    corrframe : array contenente gli angoli tra i gradienti delle immagini
    sima1     : ima1 smussato con un filtro gaussiano 2D
    sima2     : ima2 smussato con un filtro gaussiano 2D
    """
    # Verifica che le immagini abbiano la stessa dimensione
    assert ima1.shape == ima2.shape, "Le dimensioni di ima1 e ima2 devono coincidere"

    # Assegna pesi se non specificati
    if weights is None:
        weights = np.ones_like(ima1)

    # Assegna maschere se non sono specificate
    if mask1 is None:
        mask1 = np.ones_like(ima1)
    if mask2 is None:
        mask2 = np.ones_like(ima2)

    # Dimensione del kernel in pixel
    pxksz = (ksz / (2 * np.sqrt(2. * np.log(2.)))) / pxsz

    # Smoothing delle immagini con un filtro gaussiano 2D
    sima1 = ndimage.gaussian_filter(ima1, sigma=pxksz)
    sima2 = ndimage.gaussian_filter(ima2, sigma=pxksz)

    # Calcolo dei gradienti delle immagini
    grad1 = np.gradient(sima1)
    grad2 = np.gradient(sima2)

    # Modulo del gradiente
    gradmod1 = np.sqrt(grad1[0]**2. + grad1[1]**2.)
    gradmod2 = np.sqrt(grad2[0]**2. + grad2[1]**2.)

    # Normalizzazione dei gradienti
    grad1normx = grad1[1] / np.where(gradmod1 == 0, 1, gradmod1)
    grad1normy = grad1[0] / np.where(gradmod1 == 0, 1, gradmod1)
    grad2normx = grad2[1] / np.where(gradmod2 == 0, 1, gradmod2)
    grad2normy = grad2[0] / np.where(gradmod2 == 0, 1, gradmod2)

    # Calcolo della correlazione tra i gradienti
    corrframe = np.arctan2(
        grad2normx * grad1normy - grad2normy * grad1normx,
        grad2normx * grad1normx + grad2normy * grad1normy
    )

    # Soglie di gradiente
    if gradthres1 is None:
        gradthres1 = np.percentile(gradmod1[np.isfinite(gradmod1)], 15)
    if gradthres2 is None:
        gradthres2 = np.percentile(gradmod2[np.isfinite(gradmod2)], 15)

    # Applicazione delle maschere e soglie
    corrframe[
        np.logical_or(
            np.logical_or(gradmod1 <= gradthres1, gradmod2 <= gradthres2),
            np.logical_or(mask1 == 0, mask2 == 0)
        )
    ] = np.nan

    # Simulazioni Monte Carlo
    meanphis = []
    Rs = []
    Vs = []
    for run in tqdm(range(nruns), disable=not verbose):
        if nruns > 1:
            ima1_rand = np.random.normal(ima1, s_ima1) if s_ima1 is not None else ima1
            ima2_rand = np.random.normal(ima2, s_ima2) if s_ima2 is not None else ima2
        else:
            ima1_rand, ima2_rand = ima1, ima2

        # Applica l'allineamento circolare agli angoli del frame di correlazione
        alignment_res = Circular_Alignment(corrframe[np.isfinite(corrframe)], weights=weights)
        meanphis.append(alignment_res['meanPhi'])
        Rs.append(alignment_res['R'])
        Vs.append(alignment_res['V'])

    # Media e deviazione standard delle statistiche di allineamento
    mean_R = np.mean(Rs)
    std_R = np.std(Rs)
    mean_V = np.mean(Vs)
    meanphi = np.mean(meanphis)
    s_meanphi = np.std(meanphis)

    circstats = {
        'R_mean': mean_R,
        'R_std': std_R,
        'V_mean': mean_V,
        'meanphi': meanphi,
        's_meanphi': s_meanphi
    }

    return circstats, corrframe, sima1, sima2

# Caricamento delle immagini
image1 = imageo.imread('C:/Users/lollo/OneDrive/Desktop/image.001.png', mode='F')
image2 = imageo.imread('C:/Users/lollo/OneDrive/Desktop/image.002.png', mode='F')

# Visualizzazione delle immagini
fig, ax = plt.subplots(1, 2, figsize=(16., 12.))
ax[0].imshow(image1, origin='lower', interpolation='none', cmap='Greys_r')
ax[0].set_title('Image 1')
ax[1].imshow(image2, origin='lower', interpolation='none', cmap='Greys_r')
ax[1].set_title('Image 2')
plt.show()

# Dimensione del kernel
ksz = 9

# Definizione delle maschere
sz1 = np.shape(image1)
mask1 = np.ones_like(image1)
mask1[0:ksz, :] = 0
mask1[sz1[0]-1-ksz:sz1[0], :] = 0
mask1[:, 0:ksz] = 0
mask1[:, sz1[1]-1-ksz:sz1[1]] = 0

sz2 = np.shape(image2)
mask2 = np.ones_like(image2)
mask2[0:ksz, :] = 0
mask2[sz2[0]-1-ksz:sz2[0], :] = 0
mask2[:, 0:ksz] = 0
mask2[:, sz2[1]-1-ksz:sz2[1]] = 0

# Calcolo della correlazione e delle statistiche usando l'allineamento circolare
circstats, corrframe, smoothframe1, smoothframe2 = HOGcorr_ima_circ_align(
    image1, image2, ksz=ksz, mask1=mask1, mask2=mask2, 
    s_ima1=0.1*np.nanmin(image1), s_ima2=0.1*np.nanmin(image2), nruns=3
)

# Stampa delle statistiche di correlazione
print('Mean angle (phi)        ', circstats['meanphi'], '+/-', circstats['s_meanphi'])
print('Raggio medio (R)        ', circstats['R_mean'], '+/-', circstats['R_std'])
print('Varianza circolare (V)  ', circstats['V_mean'])
# Nota: la statistica Kuiper non è inclusa in questo metodo

# Computazione dei gradienti
dI1dx = ndimage.gaussian_filter(smoothframe1, [ksz, ksz], order=[0, 1], mode='nearest')
dI1dy = ndimage.gaussian_filter(smoothframe1, [ksz, ksz], order=[1, 0], mode='nearest')
normgrad1 = np.sqrt(dI1dx**2 + dI1dy**2)
udI1dx = dI1dx / normgrad1
udI1dy = dI1dy / normgrad1
psi1 = np.arctan2(dI1dy, dI1dx)

dI2dx = ndimage.gaussian_filter(smoothframe2, [ksz, ksz], order=[0, 1], mode='nearest')
dI2dy = ndimage.gaussian_filter(smoothframe2, [ksz, ksz], order=[1, 0], mode='nearest')
normgrad2 = np.sqrt(dI2dx**2 + dI2dy**2)
udI2dx = dI2dx / normgrad2
udI2dy = dI2dy / normgrad2
psi2 = np.arctan2(dI2dy, dI2dx)

# Visualizzazione dei gradienti
pitch = 50
sz = np.shape(image1)
X, Y = np.meshgrid(np.arange(0, sz[1]-1, pitch), np.arange(0, sz[0]-1, pitch))
ux1 = np.cos(psi1[Y, X])
uy1 = np.sin(psi1[Y, X])
ux2 = np.cos(psi2[Y, X])
uy2 = np.sin(psi2[Y, X])

fig, ax = plt.subplots(1, 2, figsize=(18., 12.))
ax[0].imshow(normgrad1, origin='lower', interpolation='none', cmap='Greys_r')
arrows1 = ax[0].quiver(X, Y, ux1, uy1, units='width', color='cyan', pivot='middle', width=0.005, headwidth=2, headlength=4)
ax[0].set_title('Image 1 gradient magnitude and direction')
ax[1].imshow(normgrad2, origin='lower', interpolation='none', cmap='Greys_r')
arrows2 = ax[1].quiver(X, Y, ux2, uy2, units='width', color='orange', pivot='middle', width=0.005, headwidth=2, headlength=4)
ax[1].set_title('Image 2 gradient magnitude and direction')
plt.show()

# Visualizzazione dell'orientamento relativo tra gradienti
fig, ax = plt.subplots(1, 1, figsize=(9., 6.))
im = plt.imshow(np.abs(corrframe) * 180.0 / np.pi, origin='lower', cmap='spring', interpolation='none')
cb1 = plt.colorbar(im, fraction=0.046, pad=0.04)
cb1.set_label(r'$|\phi|$ [deg]')
ax.set_title('Relative orientation between gradients')
plt.show()
