import numpy as np
from scipy.stats import circmean, circstd

def HOG_WatsonU2(phi, weights=None, s_phi=None, nruns=1):
    # Calcola la statistica di Watson U2 per la distribuzione di angoli phi
    #
    # INPUTS
    # phi      - angoli tra -pi e pi
    # weights  - pesi statistici
    # s_phi    - deviazione standard degli angoli (per simulazioni Monte Carlo)
    # nruns    - numero di run per le simulazioni Monte Carlo
    #
    # OUTPUTS
    # U2       - valore della statistica di Watson U2
    # s_U2     - errore standard della statistica U2
    # meanPhi  - media circolare degli angoli

    if np.logical_or(s_phi is None, nruns < 2):
        output = HOG_WatsonU2lite(phi, weights=weights)
        return {
            'U2': output['U2'], 's_U2': np.nan, 'meanphi': output['meanphi'], 
            's_meanphi': np.nan, 'ngood': output['ngood']
        }

    else:
        arrngood = np.zeros(nruns)
        arrU2 = np.zeros(nruns)
        arrmeanphi = np.zeros(nruns)

        for i in range(nruns):
            inmaprand = np.random.normal(loc=phi, scale=s_phi)
            output = HOG_WatsonU2lite(inmaprand, weights=weights)
            arrngood[i] = output['ngood']
            arrU2[i] = output['U2']
            arrmeanphi[i] = output['meanphi']

        ngood = np.nanmean(arrngood)
        U2 = np.nanmean(arrU2)
        s_U2 = np.nanstd(arrU2)
        meanphi = circmean(arrmeanphi, low=-np.pi, high=np.pi)
        s_meanphi = circstd(arrmeanphi, low=-np.pi, high=np.pi)

        return {
            'U2': U2, 's_U2': s_U2, 'meanphi': meanphi, 's_meanphi': s_meanphi, 'ngood': ngood
        }

def HOG_WatsonU2lite(angles, weights=None):
    # Calcola la statistica di Watson U2 per la distribuzione di angoli
    #
    # INPUTS
    # angles   - angoli tra -pi e pi
    # weights  - pesi statistici (facoltativi)
    #
    # OUTPUTS
    # U2       - valore della statistica di Watson U2
    # meanPhi  - media circolare degli angoli

    if weights is None:
        weights = np.ones_like(angles)

    angles = np.mod(angles, 2 * np.pi)  # Normalizza gli angoli tra 0 e 2*pi

    n = len(angles)
    
    # Ordina gli angoli e i pesi
    sorted_indices = np.argsort(angles)
    sorted_angles = angles[sorted_indices]
    sorted_weights = weights[sorted_indices]

    # Distribuzione cumulativa empirica pesata
    cumulative_weights = np.cumsum(sorted_weights) / np.sum(sorted_weights)
    
    # Distribuzione teorica uniforme
    uniform_dist = (sorted_angles + np.pi) / (2 * np.pi)  # Normalizza tra 0 e 1

    # Deviazioni dalla distribuzione uniforme
    D = cumulative_weights - uniform_dist

    # Calcolo della statistica di Watson U2
    U2 = np.sum(D**2) + np.sum(D)**2 / n - np.sum(D * np.mean(D))

    # Media circolare
    meanphi = circmean(angles, low=0, high=2 * np.pi)

    ngood = float(np.size(angles))

    return {'U2': U2, 'meanphi': meanphi, 'ngood': ngood}

