# #!/usr/bin/env python
#
# This file is part of astroHOG
#
# CONTACT: juandiegosolerp[at]gmail.com
# Copyright (C) 2017-2023 Juan Diego Soler

"""
astroHOG Statistical tests
"""

import numpy as np
from scipy.stats import circmean, circstd
#--------------------------------------------------------------------------------------------------------
def HOG_Kuiper(phi, weights=None, s_phi=None, nruns=1):
    # Calcola la statistica di Kuiper per la distribuzione di angoli phi
    #
    # INPUTS
    # phi      - angoli tra -pi e pi
    # weights  - pesi statistici
    # s_phi    - deviazione standard degli angoli (per simulazioni Monte Carlo)
    # nruns    - numero di run per le simulazioni Monte Carlo
    #
    # OUTPUTS
    # V        - valore della statistica di Kuiper
    # s_V      - errore standard della statistica V
    # meanPhi  - media circolare degli angoli

    if np.logical_or(s_phi is None, nruns < 2):
        output = HOG_Kuiperlite(phi, weights=weights)
        return {
            'V': output['V'], 's_V': np.nan, 'Vx': output['Vx'], 'meanphi': output['meanphi'],
            's_meanphi': np.nan, 'ngood': output['ngood']
        }

    else:
        arrngood = np.zeros(nruns)
        arrV = np.zeros(nruns)
        arrVx = np.zeros(nruns)
        arrmeanphi = np.zeros(nruns)

        for i in range(nruns):
            inmaprand = np.random.normal(loc=phi, scale=s_phi)
            output = HOG_Kuiperlite(inmaprand, weights=weights)
            arrngood[i] = output['ngood']
            arrV[i] = output['V']
            arrVx[i] = output['Vx']
            arrmeanphi[i] = output['meanphi']

        ngood = np.nanmean(arrngood)
        V = np.nanmean(arrV)
        s_V = np.nanstd(arrV)
        Vx = np.nanmean(arrVx)
        meanphi = circmean(arrmeanphi, low=-np.pi, high=np.pi)
        s_meanphi = circstd(arrmeanphi, low=-np.pi, high=np.pi)

        return {
            'V': V, 's_V': s_V, 'Vx': Vx, 'meanphi': meanphi, 's_meanphi': s_meanphi, 'ngood': ngood
        }
#--------------------------------------------------------------------------------------------------------
def HOG_Kuiperlite(angles, weights=None):
    # Calcola la statistica di Kuiper per la distribuzione di angoli
    #
    # INPUTS
    # angles   - angoli tra -pi e pi
    # weights  - pesi statistici
    #
    # OUTPUTS
    # V        - valore della statistica di Kuiper
    # meanPhi  - media circolare degli angoli

    if weights is None:
        weights = np.ones_like(angles)

    # Ordina gli angoli e i pesi
    sorted_indices = np.argsort(angles)
    sorted_angles = angles[sorted_indices]
    sorted_weights = weights[sorted_indices]

    # Distribuzione cumulativa empirica pesata
    cumulative_weights = np.cumsum(sorted_weights) / np.sum(sorted_weights)
    sorted_angles = (sorted_angles + np.pi) / (2 * np.pi)  # normalizza tra 0 e 1

    # Differenza massima con la distribuzione uniforme teorica
    D_plus = np.max(cumulative_weights - sorted_angles)
    D_minus = np.max(sorted_angles - (cumulative_weights - sorted_weights / np.sum(sorted_weights)))

    # Statistica di Kuiper
    V = D_plus + D_minus

    # Media circolare
    meanphi = circmean(angles, low=-np.pi, high=np.pi)

    ngood = float(np.size(angles))

    return {'V': V, 'Vx': D_plus, 'meanphi': meanphi, 'ngood': ngood}





